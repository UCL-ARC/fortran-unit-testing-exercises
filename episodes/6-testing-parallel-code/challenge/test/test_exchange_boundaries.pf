!> Module for testing the subroutine game_of_life::exchange_boundaries
module test_exchange_boundaries
    use comms, only : exchange_boundaries, DomainDecomposition, DOWN, LEFT, UP, RIGHT
    ! allow(C121)
    use pfunit
    implicit none

    public

    !> Type to bundle inputs and expected outputs of game_of_life::exchange_boundaries
    @testParameter(constructor=new_exchange_boundaries_test_params)
    type, extends(MPITestParameter) :: exchange_boundaries_test_params
        integer, dimension(:,:,:), allocatable :: input_board, expected_output_board
        integer :: ny, nx
        integer, dimension(:,:), allocatable :: neighbours
    end type exchange_boundaries_test_params

    !> Type to define a single exchange_boundaries test case
    @TestCase(testParameters={getParameters()}, constructor=newTest)
    type, extends(MPITestCase) :: exchange_boundaries_test_case
        type(exchange_boundaries_test_params) :: params
    end type exchange_boundaries_test_case

contains

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ! Test Suites
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    !> Test suite for the game_of_life::exchange_boundaries subroutine
    function getParameters() result(params)
        type(exchange_boundaries_test_params), allocatable :: params(:)

        integer :: max_num_ranks, num_ranks, rank, i

        integer, dimension(:,:,:), allocatable :: input_board, expected_output_board
        integer, dimension(:,:), allocatable :: neighbours
        integer :: ny, nx

        max_num_ranks = 4
        allocate(params(max_num_ranks))

        ny = 31
        nx = 31
        allocate(input_board(nx+2, ny+2, max_num_ranks))
        allocate(expected_output_board(nx+2, ny+2, max_num_ranks))
        allocate(neighbours(4, max_num_ranks))

        do num_ranks = 1, max_num_ranks
            ! Initialise neighbours to catch any mistakes in parameter setup
            neighbours = -2

            do i = 1, num_ranks
                rank = i-1

                ! Fill boards with the rank of the process
                input_board(:,:,i) = rank
                expected_output_board(:,:,i) = rank

                ! Define neighbours and expected halos for num_ranks == 2 test case
                if (num_ranks == 2 ) then
                    if (rank == 0) then
                        neighbours(UP, i) = 1 ! Top halo should be received from rank 1
                        expected_output_board(:, ny+2, i) = neighbours(UP, i)
                    else if (rank == 1) then
                        neighbours(DOWN, i) = 0 ! Bottom halo should be received from rank 0
                        expected_output_board(:, 1, i) = neighbours(DOWN, i)
                    end if

                ! Define neighbours and expected halos for num_ranks == 3 test case
                else if (num_ranks == 3) then
                    if (rank == 0) then
                        neighbours(UP, i) = 1 ! Top halo should be received from rank 1
                        expected_output_board(:, ny+2, i) = neighbours(UP, i)
                    else if (rank == 1) then
                        neighbours(DOWN, i) = 0 ! Bottom halo should be received from rank 0
                        neighbours(UP, i) = 2 ! Top halo should be received from rank 2
                        expected_output_board(:, ny+2, i) = neighbours(UP, i)
                        expected_output_board(:, 1, i) = neighbours(DOWN, i)
                    else if (rank == 2) then
                        neighbours(DOWN, i) = 1 ! Bottom halo should be received from rank 1
                        expected_output_board(:, 1, i) = neighbours(DOWN, i)
                    end if

                ! Define neighbours and expected halos for num_ranks == 4 test case
                else if (num_ranks == 4) then
                    if (rank == 0) then
                        neighbours(UP, i) = 2 ! Top halo should be received from rank 2
                        neighbours(RIGHT, i) = 1 ! Right halo should be received from rank 1
                        expected_output_board(:, ny+2, i) = neighbours(UP, i)
                        expected_output_board(nx+2, :, i) = neighbours(RIGHT, i)
                    else if (rank == 1) then
                        neighbours(LEFT, i) = 0 ! Left halo should be received from rank 0
                        neighbours(UP, i) = 3 ! Top halo should be received from rank 3
                        expected_output_board(:, ny+2, i) = neighbours(UP, i)
                        expected_output_board(1, :, i) = neighbours(LEFT, i)
                    else if (rank == 2) then
                        neighbours(DOWN, i) = 0 ! Bottom halo should be received from rank 0
                        neighbours(RIGHT, i) = 3 ! Right halo should be received from rank 3
                        expected_output_board(:, 1, i) = neighbours(DOWN, i)
                        expected_output_board(nx+2, :, i) = neighbours(RIGHT, i)
                    else if (rank == 3) then
                        neighbours(DOWN, i) = 1 ! Bottom halo should be received from rank 1
                        neighbours(LEFT, i) = 2 ! Left halo should be received from rank 2
                        expected_output_board(:, 1, i) = neighbours(DOWN, i)
                        expected_output_board(1, :, i) = neighbours(LEFT, i)
                    end if

                end if
            end do
            params(num_ranks) = exchange_boundaries_test_params(num_ranks, input_board, expected_output_board, ny, nx, neighbours)
        end do
    end function getParameters

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ! Assertion functions
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    !> Check for the expected output of the game_of_life::exchange_boundaries subroutine
    @Test
    subroutine TestExchangeBoundaries(this)
        class(exchange_boundaries_test_case), intent(inout) :: this

        integer, dimension(:,:), allocatable ::actual_board

        integer :: rank_index
        type(DomainDecomposition) :: domainDecomp

        rank_index = this%getProcessRank() + 1
        
        domainDecomp%communicator = this%getMpiCommunicator()
        domainDecomp%neighbours = this%params%neighbours(:,rank_index)


        allocate(actual_board(size(this%params%input_board, 1), size(this%params%input_board, 2)))
        actual_board = this%params%input_board(:,:,rank_index)

        call exchange_boundaries(actual_board, this%params%ny, this%params%nx, domainDecomp)

        @assertEqual(this%params%expected_output_board(2:this%params%nx+1,2:this%params%ny+1,rank_index), actual_board(2:this%params%nx+1,2:this%params%ny+1), "Unexpected centre of board")

        ! For simplicity, do not check corners as these cannot be 100% known at this point due to timings of MPI messages
        @assertEqual(this%params%expected_output_board(2:this%params%nx+1,1,rank_index), actual_board(2:this%params%nx+1,1), "Unexpected bottom halo")
        @assertEqual(this%params%expected_output_board(2:this%params%nx+1,this%params%ny+2,rank_index), actual_board(2:this%params%nx+1,this%params%ny+2), "Unexpected top halo")
        @assertEqual(this%params%expected_output_board(1,2:this%params%ny+1,rank_index), actual_board(1,2:this%params%ny+1), "Unexpected left halo")
        @assertEqual(this%params%expected_output_board(this%params%nx+2,2:this%params%ny+1,rank_index), actual_board(this%params%nx+2,2:this%params%ny+1), "Unexpected right halo")

        deallocate(actual_board)
    end subroutine TestExchangeBoundaries

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ! Constructors
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    function new_exchange_boundaries_test_params(input_board, expected_output_board, ny, nx, neighbours) result(new_params)
        integer, dimension(:,:,:), allocatable, intent(in) :: input_board, expected_output_board
        integer, intent(in) :: ny, nx
        integer, dimension(:,:), allocatable, intent(in) :: neighbours

        type(exchange_boundaries_test_params) :: new_params

        allocate(new_params%input_board(size(input_board, 1), size(input_board, 2), size(input_board, 3)))
        allocate(new_params%expected_output_board(size(expected_output_board, 1), size(expected_output_board, 2), &
                                                  size(expected_output_board, 3)))
        allocate(new_params%neighbours(size(neighbours, 1), size(neighbours, 2)))

        new_params%input_board = input_board
        new_params%expected_output_board = expected_output_board
        new_params%ny = ny
        new_params%nx = nx
        new_params%neighbours = neighbours

    end function new_exchange_boundaries_test_params

    function newTest(testParameter) result(tst)
        type(exchange_boundaries_test_case) :: tst
        type(exchange_boundaries_test_params), intent(in) :: testParameter

        tst%params = testParameter
    end function newTest
end module test_exchange_boundaries
