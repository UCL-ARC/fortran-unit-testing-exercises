!> Module for testing the subroutine game_of_life::check_for_steady_state
module test_check_for_steady_state
    use game_of_life_mod, only : check_for_steady_state
    use funit
    implicit none

    !> Type to bundle inputs and expected outputs of game_of_life::check_for_steady_state
    @testParameter
    type, extends(AbstractTestParameter) :: check_for_steady_state_in_out_t
        integer, dimension(:,:), allocatable :: current_board, new_board
        logical :: expected_steady_state
        character(len=100) :: description
    contains
        procedure :: toString => check_for_steady_state_in_out_toString
    end type check_for_steady_state_in_out_t

    !> Type to define a single check_for_steady_state test case
    @TestCase(testParameters={getParameters()}, constructor=newTest)
    type, extends(ParameterizedTestCase) :: check_for_steady_state_test_case
        type(check_for_steady_state_in_out_t) :: params
    end type check_for_steady_state_test_case

contains

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ! Test Suites
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    !> Test suite for the game_of_life::check_for_steady_state subroutine
    function getParameters() result(params)
        type(check_for_steady_state_in_out_t), allocatable :: params(:)

        integer :: nrow, ncol
        integer, dimension(:,:), allocatable :: test_current_board, test_new_board

        allocate(params(6))
        
        nrow = 31
        ncol = 31

        ! Allocate arrays
        allocate(test_current_board(nrow, ncol))
        allocate(test_new_board(nrow, ncol))

        ! Matching boards
        !  All zeros
        call populate_random_boards(test_current_board, test_new_board, 0, .true.)
        params(1) = check_for_steady_state_in_out_t(test_current_board, test_new_board, .true., "all zeros")
        !  All ones
        call populate_random_boards(test_current_board, test_new_board, nrow*ncol, .true.)
        params(2) = check_for_steady_state_in_out_t(test_current_board, test_new_board, .true., "all ones")
        !  Up to 10 ones
        call populate_random_boards(test_current_board, test_new_board, 10, .true.)
        params(3) = check_for_steady_state_in_out_t(test_current_board, test_new_board, .true., "up to ten ones")

        ! Mismatched boards
        !  All ones vs all zeros
        call populate_random_boards(test_current_board, test_new_board, 0, .false.)
        params(4) = check_for_steady_state_in_out_t(test_current_board, test_new_board, .false., "all ones and all zeros")
        !  All zeros vs all ones
        call populate_random_boards(test_current_board, test_new_board, nrow*ncol, .false.)
        params(5) = check_for_steady_state_in_out_t(test_current_board, test_new_board, .false., "all zeros and all ones")
        !  Up to 10 differences
        call populate_random_boards(test_current_board, test_new_board, 10, .false.)
        params(6) = check_for_steady_state_in_out_t(test_current_board, test_new_board, .false., "up to ten differences")
    end function getParameters

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ! Assertion functions
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    !> Check for the expected output of the game_of_life::check_for_steady_state subroutine
    @Test
    subroutine TestCheckIfSteadyState(this)
        class(check_for_steady_state_test_case), intent(inout) :: this

        logical :: actual_steady_state

        call check_for_steady_state(this%params%current_board, this%params%new_board, actual_steady_state)

        @assertEqual(this%params%expected_steady_state, actual_steady_state)


    end subroutine TestCheckIfSteadyState

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ! Contructors
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    function newTest(testParameter) result(tst)
        type(check_for_steady_state_test_case) :: tst
        type(check_for_steady_state_in_out_t), intent(in) :: testParameter

        integer :: nrow, ncol

        nrow = size(testParameter%current_board, 1)
        ncol = size(testParameter%current_board, 2)

        allocate(tst%params%current_board(nrow, ncol))
        allocate(tst%params%new_board(nrow, ncol))

        tst%params%current_board = testParameter%current_board
        tst%params%new_board = testParameter%new_board
        tst%params%expected_steady_state = testParameter%expected_steady_state
    end function newTest

    function check_for_steady_state_in_out_toString(this) result(string)
        class(check_for_steady_state_in_out_t), intent(in) :: this
        character(:), allocatable :: string

        character(len=80) :: buffer

        integer :: nrow, ncol

        nrow = size(this%current_board, 1)
        ncol = size(this%current_board, 2)

        if (this%expected_steady_state) then
            write(buffer,'("Steady state ", i2, "x", i2, " boards with ", a)') &
                nrow, ncol, trim(this%description)
        else
            write(buffer,'("Non steady state ", i2, "x", i2, " boards with ", a)') &
                nrow, ncol, trim(this%description)
        end if
        string = trim(buffer)
    end function check_for_steady_state_in_out_toString

    subroutine populate_random_boards(current_board, new_board, num_differences, matching)
        integer, dimension(:,:), allocatable, intent(inout) :: current_board, new_board
        integer, intent(in) :: num_differences
        logical, intent(in) :: matching

        integer :: nrow, ncol, row, col, rand_row, rand_col, new_board_val
        real :: rand_real

        ! Initialise
        nrow = size(current_board, 1)
        ncol = size(current_board, 2)
        current_board = 0

        if (matching) then
            new_board = 0
        else
            new_board = 1
        end if

        ! For both boards, set to requested number of elements to the opposite value
        do row = 1, num_differences
            ! Get random coordinates for current
            call random_number(rand_real)
            rand_row = 1 + FLOOR(nrow*rand_real) ! n=1 to n=nrow
            call random_number(rand_real)
            rand_col = 1 + FLOOR(ncol*rand_real) ! n=1 to n=ncol

            current_board(rand_row, rand_col) = 1

            if (.not. matching) then
                ! Get random coordinates for new
                call random_number(rand_real)
                rand_row = 1 + FLOOR(nrow*rand_real) ! n=1 to n=nrow
                call random_number(rand_real)
                rand_col = 1 + FLOOR(ncol*rand_real) ! n=1 to n=ncol

                new_board(rand_row, rand_col) = 0
            else
                new_board(rand_row, rand_col) = 1
            end if


        end do

    end subroutine populate_random_boards

    function check_for_steady_state_in_out_constructor(current_board, new_board, steady_state) result(check_for_steady_state_in_out)
        integer, dimension(:,:), allocatable, intent(in) :: current_board, new_board
        logical, intent(in) :: steady_state

        type(check_for_steady_state_in_out_t) :: check_for_steady_state_in_out

        check_for_steady_state_in_out%current_board = current_board
        check_for_steady_state_in_out%new_board = new_board
        check_for_steady_state_in_out%expected_steady_state = steady_state

    end function check_for_steady_state_in_out_constructor
end module test_check_for_steady_state
