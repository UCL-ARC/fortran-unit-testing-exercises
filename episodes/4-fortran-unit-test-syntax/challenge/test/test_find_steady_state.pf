module test_find_steady_state
    use, intrinsic :: iso_fortran_env, only: REAL32, REAL64
    use game_of_life, only : find_steady_state
    use funit
    implicit none

    ! Define types to act as test parameters (and test case for pfunit)
    @testParameter
    type, extends(AbstractTestParameter) :: find_steady_state_test_params
        !> The initial starting board to be passed into find_steady_state
        integer, dimension(:,:), allocatable :: input_board
        !> The expected value of steady_state
        logical :: expected_steady_state
        !> The expected output generation number
        integer :: expected_generation_number
        !> A description of the test to be outputted for logging
        character(len=100) :: description
    contains
        procedure :: toString => find_steady_state_test_params_toString
    end type find_steady_state_test_params

    @TestCase(testParameters={getTestSuite()}, constructor=paramsToCase)
    type, extends(ParameterizedTestCase) :: find_steady_state_test_case
        type(find_steady_state_test_params) :: params
    end type find_steady_state_test_case
contains

    ! Define a test suite (collection of tests) to be returned from a procedure
    function getTestSuite() result(params)                                     
        type(find_steady_state_test_params), allocatable :: params(:)

        integer, dimension(:,:), allocatable :: board

        allocate(board(31,31))
        board = 0
        board(9, 9:11) = [0,1,0]
        board(10,9:11) = [1,1,1]
        board(11,9:11) = [1,0,1]
        board(12,9:11) = [0,1,0]
        params = [find_steady_state_test_params(board, .true., 17, "an exploder initial state")]
    end function getTestSuite

    ! Define the actual test execution code which will call the src and execute assertions
    @Test
    subroutine TestFindSteadyState(this)
        class(find_steady_state_test_case), intent(inout) :: this

        logical :: actual_steady_state
        integer :: actual_generation_number

        call find_steady_state(.false., this%params%input_board, actual_steady_state, actual_generation_number)

        @assertEqual(this%params%expected_generation_number, actual_generation_number, "Unexpected generation_number")
        
        @assertLessThan(this%params%expected_generation_number, 16.1_real64)

        @assertTrue(this%params%expected_steady_state .eqv. actual_steady_state, "Unexpected steady_state value")

    end subroutine TestFindSteadyState

    ! Define constructors for your derived types (test parameters/cases)
    function paramsToCase(testParameter) result(tst)
        type(find_steady_state_test_params), intent(in) :: testParameter
        type(find_steady_state_test_case) :: tst
        tst%params = testParameter
    end function paramsToCase

    function find_steady_state_test_params_toString(this) result(string)
        class (find_steady_state_test_params), intent(in) :: this
        character(:), allocatable :: string

        character(len=80) :: buffer
        integer :: nrow, ncol

        nrow = size(this%input_board, 1)
        ncol = size(this%input_board, 2)
        write(buffer,'(i2, "x", i2, " board with ", a)') &
            nrow, ncol, trim(this%description)

        string = trim(buffer)
    end function find_steady_state_test_params_toString
end module test_find_steady_state