!> Module for testing the subroutine game_of_life::exchange_boundaries
module test_exchange_boundaries
    use game_of_life_mod, only : exchange_boundaries
    use pfunit
    implicit none

    !> Type to bundle inputs and expected outputs of game_of_life::exchange_boundaries
    @testParameter!(constructor=newParams)
    type, extends(MPITestParameter) :: exchange_boundaries_test_params
        integer, dimension(:,:), allocatable :: input_board, expected_output_board
        integer :: local_ny, local_nx, neighbours(4)
    end type exchange_boundaries_test_params

    !> Type to define a single exchange_boundaries test case
    @TestCase(testParameters={getParameters()}, constructor=newTest)
    type, extends(MPITestCase) :: exchange_boundaries_column_only_test_case
        type(exchange_boundaries_test_params) :: params
        integer :: cart_comm
    contains
        procedure :: setUp
    end type exchange_boundaries_column_only_test_case

contains

    subroutine setUp(this)
        class(exchange_boundaries_column_only_test_case), intent(inout) :: this

        integer :: ierr, dims(2)

        dims = 0
        call MPI_Dims_create(this%getNumProcesses(), 2, dims, ierr) 
        call MPI_Cart_create(this%getMpiCommunicator(), 2, dims, [.false.,.false.], .true., this%cart_comm, ierr)
    end subroutine setUp

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ! Test Suites
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    !> Test suite for the game_of_life::exchange_boundaries subroutine
    function getParameters() result(params)
        type(exchange_boundaries_test_params), allocatable :: params(:)

        integer :: rank, ierr

        integer, dimension(:,:), allocatable :: input_board, expected_output_board
        integer :: ny, nx, neighbours(4)


        allocate(params(4))
        call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)
        
        ny = 31
        nx = 31
        allocate(input_board(nx+2, ny+2))
        allocate(expected_output_board(nx+2, ny+2))

        ! One rank
        input_board = 0
        expected_output_board = 0
        neighbours = -2
        params(1) = exchange_boundaries_test_params(1, input_board, expected_output_board, ny, nx, neighbours)

        ! Two ranks
        input_board = rank
        expected_output_board = rank
        neighbours = -2
        if (rank == 0) then
            expected_output_board(2:nx+1, ny+2) = 1 ! Top halo should be received from rank 1
            neighbours = [-2,-2,1,-2]
        else if (rank == 1) then
            expected_output_board(2:nx+1, 1) = 0 ! Bottom halo should be received from rank 0
            neighbours = [0,-2,-2,-2]
        end if
        params(2) = exchange_boundaries_test_params(2, input_board, expected_output_board, ny, nx, neighbours)

        ! Three ranks
        input_board = rank
        expected_output_board = rank
        neighbours = -2
        if (rank == 0) then
            expected_output_board(2:nx+1, ny+2) = 1 ! Top halo should be received from rank 1
            neighbours = [-2,-2,1,-2]
        else if (rank == 1) then
            expected_output_board(2:nx+1, ny+2) = 2 ! Top halo should be received from rank 2
            expected_output_board(2:nx+1, 1) = 0 ! Bottom halo should be received from rank 0
            neighbours = [0,-2,2,-2]
        else if (rank == 2) then
            expected_output_board(2:nx+1, 1) = 1 ! Bottom halo should be received from rank 1
            neighbours = [1,-2,-2,-2]
        end if
        params(3) = exchange_boundaries_test_params(3, input_board, expected_output_board, ny, nx, neighbours)

        ! Four ranks
        input_board = rank
        expected_output_board = rank
        neighbours = -2
        if (rank == 0) then
            expected_output_board(2:nx+1, ny+2) = 2 ! Top halo should be received from rank 2
            expected_output_board(nx+2, 2:ny+1) = 1 ! Right halo should be received from rank 1
            neighbours = [-2,-2,2,1]
        else if (rank == 1) then
            expected_output_board(2:nx+1, ny+2) = 3 ! Top halo should be received from rank 3
            expected_output_board(1, 2:ny+1) = 0 ! Left halo should be received from rank 0
            neighbours = [-2,0,3,-2]
        else if (rank == 2) then
            expected_output_board(2:nx+1, 1) = 0 ! Bottom halo should be received from rank 0
            expected_output_board(nx+2, 2:ny+1) = 3 ! Right halo should be received from rank 3
            neighbours = [0,-2,-2,3]
        else if (rank == 3) then
            expected_output_board(2:nx+1, 1) = 1 ! Bottom halo should be received from rank 1
            expected_output_board(1, 2:ny+1) = 2 ! Left halo should be received from rank 2
            neighbours = [1,2,-2,-2]
        end if
        params(4) = exchange_boundaries_test_params(4, input_board, expected_output_board, ny, nx, neighbours)

    end function getParameters

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ! Assertion functions
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    !> Check for the expected output of the game_of_life::exchange_boundaries subroutine
    @Test
    subroutine TestExchangeBoundaries(this)
        class(exchange_boundaries_column_only_test_case), intent(inout) :: this

        integer, dimension(:,:), allocatable ::actual_board

        allocate(actual_board(size(this%params%input_board, 1), size(this%params%input_board, 2)))
        actual_board = this%params%input_board

        write(*,*) "Hello from TestExchangeBoundaries"

        call exchange_boundaries(actual_board, this%params%local_ny, this%params%local_nx, this%cart_comm, this%params%neighbours)

        @assertEqual(this%params%expected_output_board, actual_board, "Unexpected output_board")

        deallocate(actual_board)
    end subroutine TestExchangeBoundaries

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ! Contructors
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    function newTest(testParameter) result(tst)
        type(exchange_boundaries_column_only_test_case) :: tst
        type(exchange_boundaries_test_params), intent(in) :: testParameter

        tst%params = testParameter
    end function newTest
end module test_exchange_boundaries
